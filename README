tdlib provides tree decomposition algorithms

A tree decomposition of a simple loopless graph G is a tree T with bags at its
nodes containing vertices from G. The usual conditions apply. By convention,
a tree is an acyclic graph with exactly one connected component. The bagsize
of T is the size of the biggest bag, which is a more natural notion for the
(width of T)+1.

there is work in progress, so this description should be understood as
normative. deviations from conventions stated here are considered bugs.

== the interface ==

a tree decomposition algorithm is a class template

template<class G, template<class G_, class ...> class C>
class ALGORITHM{
[..]
};

where G is a graph and C is a config object. a graph is expected to come with
a boost graph interface. there are some extra implicit assumptions, which the
graph data structure may or may not enforce.

an algorithm has (should have) a constructor taking G& and a constructor
taking const G&. you should expect the argument to be modified, unless it's
const. i.e. make sure to cast to const reference, if this is not desired.

an algorithm also provides
T get_tree_decomposition() const;
template<class TT>
void get_tree_decomposition(TT&) const;
which is meant to work with treedecomposition types (see below).

== graph types ==

A graph is expected to be a model of AdjacencyGraph, but without self loops
and without parallel edges. Graphs that model BidirectionalGraph must not
contain more than one edge for any two vertices, as accessed through
boost::edges. Other graphs need to contain an edge (u,v) for each edge (v,u).

(this sounds complicated, but actually we just make sure that we can reach
neighbours with reasonable effort).

(TODO: really implement it that way.)

== configuration objects ==

Config objects can control some of the algorithm behaviour, such as statistics
generation, debug output, signalling and subalgorithm/subroutine/data\
structure selection. The default, algo::cfg_default is a sensible choice, if
you don't care.

(TODO: more on config objects)

== tree decompositions ==

a tree decomposition is a boost graph with a undirected edges and a vertex
property of access type treedec::bag_t.

a possible model is

#include <tdlib/treedec_traits>
typedef std::vector<vertex_descriptor> bag_container_type;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
        boost::property<treedec::bag_t, bag_container_type> > T;

where vertex_descriptor must be compatible with the graph to be decomposed.

it is possible to use custom tree decomposition types, such as with bundled
properties. if you have a graph

struct mybundle{
   std::set<unsigned> bag; // BUG. must be "bag" right now.
   [..]
};
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
                              mybundle> my_td_type;

you can make bags accessible from tdlib using

REGISTER_GRAPH_WITH_BUNDLED_BAGS(my_td_type, bag);
